/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/anchor.js":
/*!***********************!*\
  !*** ./src/anchor.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nvar _require = __webpack_require__(/*! events */ \"./node_modules/events/events.js\"),\n  EventEmitter = _require.EventEmitter;\nvar TimeUtils = __webpack_require__(/*! ./time-utils */ \"./src/time-utils.js\");\nvar Visualization = __webpack_require__(/*! ./visualization */ \"./src/visualization.js\");\nvar Utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\nvar sendMessageButton = document.getElementById(\"sendMessageButton\");\nvar resetButton = document.getElementById(\"resetButton\");\nvar clientSelect = document.getElementById(\"clientSelect\");\nvar popover1 = document.getElementById(\"popoverButton1\");\nvar popover2 = document.getElementById(\"popoverButton2\");\nvar popover3 = document.getElementById(\"popoverButton3\");\nvar speedSlider = document.getElementById(\"speedSlider\");\nvar awaitTime = speedSlider.value;\nvar transactionCounter = 0;\nfunction setTimeoutPromise(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\nvar Message = /*#__PURE__*/_createClass(function Message(_ref) {\n  var requestServerId = _ref.requestServerId,\n    roundId = _ref.roundId,\n    toServer = _ref.toServer,\n    command = _ref.command,\n    content = _ref.content;\n  _classCallCheck(this, Message);\n  this.requestServerId = requestServerId;\n  this.roundId = roundId;\n  this.toServer = toServer;\n  this.command = command;\n  this.content = content;\n});\nvar Consensus = /*#__PURE__*/function (_EventEmitter) {\n  function Consensus(nodeId, otherConsensuses) {\n    var _this;\n    _classCallCheck(this, Consensus);\n    _this = _callSuper(this, Consensus);\n    _this.nodeId = nodeId;\n    _this.activeRounds = new Map();\n    _this.commitedRounds = new Map();\n    _this.proposeAccepted = new Set();\n    _this.nonce = 0;\n    _this.connections = otherConsensuses;\n    _this.on('message', _this.handleMessage.bind(_this));\n    return _this;\n  }\n  _inherits(Consensus, _EventEmitter);\n  return _createClass(Consensus, [{\n    key: \"submitRound\",\n    value: function () {\n      var _submitRound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(transaction) {\n        var roundId,\n          displayTransaction,\n          round,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              roundId = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n              displayTransaction = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n              if (!displayTransaction) {\n                _context.next = 6;\n                break;\n              }\n              visualization.sendMessage(visualization.clients[this.nodeId - 1], visualization.nodes[this.nodeId - 1], \"\".concat(transaction), this.nonce);\n              _context.next = 6;\n              return setTimeoutPromise(awaitTime);\n            case 6:\n              if (roundId == null) {\n                this.nonce++;\n                roundId = this.nonce;\n              }\n              Utils.updateRoundId(this.nodeId, roundId);\n              round = new Round(this, roundId);\n              round.transactions.push(transaction);\n              this.activeRounds.set(roundId, round);\n              Utils.updateActiveRounds(this.nodeId, this.activeRounds.size);\n              visualization.createRound(visualization.nodes[this.nodeId - 1], roundId);\n              round.run();\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function submitRound(_x) {\n        return _submitRound.apply(this, arguments);\n      }\n      return submitRound;\n    }()\n  }, {\n    key: \"roundIsRunning\",\n    value: function roundIsRunning(roundId) {\n      return this.activeRounds.has(roundId) && !this.commitedRounds.has(roundId);\n    }\n  }, {\n    key: \"roundExists\",\n    value: function roundExists(roundId) {\n      return this.activeRounds.has(roundId) || this.activeRounds.has(roundId);\n    }\n  }, {\n    key: \"commitTransactions\",\n    value: function commitTransactions(roundId, transactions) {\n      this.commitedRounds.set(roundId, transactions);\n      Utils.updateCommitedRounds(this.nodeId, this.commitedRounds.size);\n    }\n  }, {\n    key: \"isProposeAccepted\",\n    value: function isProposeAccepted(roundId) {\n      return this.proposeAccepted.has(roundId);\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message, toNode) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // await setTimeoutPromise(awaitTime);\n              console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(this.nodeId, \" sending message:\"), message);\n              // this.connections[toNode].emit('message', message);\n              visualization.sendMessage(visualization.nodes[message.requestServerId - 1], visualization.nodes[toNode - 1], message.command, message.roundId);\n              this.connections.find(function (connection) {\n                return connection.nodeId === toNode;\n              }).emit('message', message);\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function sendMessage(_x2, _x3) {\n        return _sendMessage.apply(this, arguments);\n      }\n      return sendMessage;\n    }()\n  }, {\n    key: \"handleMessage\",\n    value: function () {\n      var _handleMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n        var command;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return setTimeoutPromise(awaitTime);\n            case 2:\n              console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(this.nodeId, \" received message:\"), message);\n              command = message.command;\n              _context3.t0 = command;\n              _context3.next = _context3.t0 === 'PROPOSE' ? 7 : _context3.t0 === 'ACCEPT' ? 9 : _context3.t0 === 'COMMIT' ? 11 : _context3.t0 === 'FORWARD' ? 13 : 15;\n              break;\n            case 7:\n              this.handlePropose(message).then(function (_) {});\n              return _context3.abrupt(\"break\", 16);\n            case 9:\n              this.handleAccept(message);\n              return _context3.abrupt(\"break\", 16);\n            case 11:\n              this.handleCommit(message);\n              return _context3.abrupt(\"break\", 16);\n            case 13:\n              this.handleForward(message);\n              return _context3.abrupt(\"break\", 16);\n            case 15:\n              console.warn(\"Invalid command: \".concat(command));\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function handleMessage(_x4) {\n        return _handleMessage.apply(this, arguments);\n      }\n      return handleMessage;\n    }()\n  }, {\n    key: \"handlePropose\",\n    value: function () {\n      var _handlePropose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(message) {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              // await setTimeoutPromise(10);\n              response = new Message({\n                requestServerId: this.nodeId,\n                roundId: message.roundId,\n                toServer: message.requestServerId,\n                command: 'ACCEPT'\n              });\n              this.proposeAccepted.add(message.roundId);\n              this.nonce = Math.max(this.nonce, message.roundId);\n              Utils.updateRoundId(this.nodeId, this.nonce);\n              this.sendMessage(response, response.toServer);\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function handlePropose(_x5) {\n        return _handlePropose.apply(this, arguments);\n      }\n      return handlePropose;\n    }()\n  }, {\n    key: \"handleAccept\",\n    value: function handleAccept(message) {\n      var round = this.activeRounds.get(message.roundId);\n      if (round) {\n        round.countDownLatch();\n      }\n    }\n  }, {\n    key: \"handleCommit\",\n    value: function handleCommit(message) {\n      var response = new Message({\n        requestServerId: this.nodeId,\n        roundId: message.roundId,\n        toServer: message.requestServerId,\n        command: 'ACCEPT'\n      });\n      var rounds = visualization.nodes[this.nodeId - 1].rounds;\n      if (rounds && visualization.findRound(rounds, message.roundId)) {\n        visualization.sendMessage(visualization.findRound(rounds, message.roundId), visualization.nodes[this.nodeId - 1], message.command, message.roundId, false);\n      }\n      this.sendMessage(response, response.toServer);\n      var round = this.activeRounds.get(message.roundId);\n      if (round) {\n        round.setTransactions(message.content);\n        round.signalReceivedCommit();\n      }\n      console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(this.nodeId, \" Round \").concat(message.roundId, \" committed with transactions:\"), message.content[0]);\n      this.commitTransactions(message.roundId, message.content[0]);\n      this.activeRounds[\"delete\"](message.roundId);\n      Utils.updateActiveRounds(this.nodeId, this.activeRounds.size);\n    }\n  }, {\n    key: \"handleForward\",\n    value: function handleForward(message) {\n      if (this.roundIsRunning(message.roundId)) {\n        this.activeRounds.get(message.roundId).addTransaction(message.content);\n      } else if (!this.roundExists(message.roundId)) {\n        this.nonce = Math.max(this.nonce, message.roundId);\n        this.submitRound(message.content, message.roundId);\n      }\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(message) {\n      console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(this.nodeId, \" broadcasting message:\"), message);\n      this.connections.forEach(function (consensus) {\n        visualization.sendMessage(visualization.nodes[message.requestServerId - 1], visualization.nodes[consensus.nodeId - 1], message.command, message.roundId);\n        consensus.emit('message', message);\n      });\n    }\n  }]);\n}(EventEmitter);\nvar Round = /*#__PURE__*/function () {\n  function Round(consensus, roundId) {\n    _classCallCheck(this, Round);\n    this.consensus = consensus;\n    this.roundId = roundId;\n    this.transactions = [];\n    this.responseLatch = this.consensus.connections.length;\n  }\n  return _createClass(Round, [{\n    key: \"setTransactions\",\n    value: function setTransactions(transactions) {\n      this.transactions = transactions;\n    }\n  }, {\n    key: \"addTransaction\",\n    value: function addTransaction(transaction) {\n      this.transactions.push(transaction);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this2 = this;\n      if (this.consensus.nodeId === this.getCoordinator()) {\n        var proposeMessage = new Message({\n          requestServerId: this.consensus.nodeId,\n          roundId: this.roundId,\n          command: 'PROPOSE'\n        });\n        this.consensus.broadcast(proposeMessage);\n        this.awaitReceivedAllResponse().then(function () {\n          var commitMessage = new Message({\n            requestServerId: _this2.consensus.nodeId,\n            roundId: _this2.roundId,\n            command: 'COMMIT',\n            content: [_this2.transactions]\n          });\n          _this2.responseLatch = _this2.consensus.connections.length;\n          _this2.consensus.broadcast(commitMessage);\n          _this2.awaitReceivedAllResponse().then(function () {\n            var rounds = visualization.nodes[_this2.consensus.nodeId - 1].rounds;\n            if (rounds && visualization.findRound(rounds, _this2.roundId)) {\n              visualization.sendMessage(visualization.findRound(rounds, _this2.roundId), visualization.nodes[_this2.consensus.nodeId - 1], \"COMMIT\", _this2.roundId, false);\n            }\n            _this2.consensus.commitTransactions(_this2.roundId, _this2.transactions);\n            _this2.consensus.activeRounds[\"delete\"](_this2.roundId);\n            Utils.updateActiveRounds(_this2.consensus.nodeId, _this2.consensus.activeRounds.size);\n            console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(_this2.consensus.nodeId, \" Round \").concat(_this2.roundId, \" committed with transactions:\"), _this2.transactions);\n          });\n        });\n      } else {\n        if (this.consensus.isProposeAccepted(this.roundId)) {\n          console.log(\"\".concat(TimeUtils.getCurrentTime(), \" C\").concat(this.consensus.nodeId, \" Round \").concat(this.roundId, \" Already accepted propose command or round is commited. Submitting new round...\"));\n          this.consensus.submitRound(this.transactions.pop());\n        } else {\n          var forwardMessage = new Message({\n            requestServerId: this.consensus.nodeId,\n            roundId: this.roundId,\n            toServer: this.getCoordinator(),\n            command: 'FORWARD',\n            content: this.transactions.pop()\n          });\n          this.consensus.sendMessage(forwardMessage, this.getCoordinator());\n        }\n      }\n    }\n  }, {\n    key: \"getCoordinator\",\n    value: function getCoordinator() {\n      // const coordinator = this.roundId % (this.consensus.connections.length + 1) + 1;\n      // console.log(`${TimeUtils.getCurrentTime()} C${this.consensus.nodeId} roundId is ${this.roundId}`)\n      // console.log(`${TimeUtils.getCurrentTime()} C${this.consensus.nodeId} coordinator is ${coordinator}`)\n      return this.roundId % (this.consensus.connections.length + 1) + 1;\n    }\n  }, {\n    key: \"awaitReceivedAllResponse\",\n    value: function () {\n      var _awaitReceivedAllResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(this.responseLatch > 0)) {\n                _context5.next = 5;\n                break;\n              }\n              _context5.next = 3;\n              return setTimeoutPromise(10);\n            case 3:\n              _context5.next = 0;\n              break;\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function awaitReceivedAllResponse() {\n        return _awaitReceivedAllResponse.apply(this, arguments);\n      }\n      return awaitReceivedAllResponse;\n    }()\n  }, {\n    key: \"countDownLatch\",\n    value: function countDownLatch() {\n      this.responseLatch -= 1;\n    }\n  }, {\n    key: \"signalReceivedCommit\",\n    value: function signalReceivedCommit() {\n      console.log(\"\".concat(TimeUtils.getCurrentTime(), \" Round \").concat(this.roundId, \" received commit.\"));\n    }\n  }]);\n}();\nvar visualization = new Visualization(awaitTime);\nvisualization.initialize();\nsendMessageButton.addEventListener(\"click\", function () {\n  var selectedClients = Array.from(clientSelect.selectedOptions).map(function (option) {\n    return visualization.clients[option.value];\n  });\n  if (selectedClients.length !== 0) {\n    selectedClients.forEach(function (client) {\n      transactionCounter++;\n      consensusNodes[client.id - 1].submitRound(\"transaction_\".concat(transactionCounter), null, true);\n    });\n  } else {\n    alert(\"Please select at least one client!\");\n  }\n});\nspeedSlider.addEventListener(\"input\", function () {\n  awaitTime = this.value;\n});\npopover1.addEventListener(\"click\", function () {\n  Utils.displayCommittedRounds(1, consensusNodes[0].commitedRounds);\n});\npopover2.addEventListener(\"click\", function () {\n  Utils.displayCommittedRounds(2, consensusNodes[1].commitedRounds);\n});\npopover3.addEventListener(\"click\", function () {\n  Utils.displayCommittedRounds(3, consensusNodes[2].commitedRounds);\n});\ndocument.addEventListener('keydown', function (event) {\n  if (event.key === 'Enter') {\n    sendMessageButton.click();\n  }\n});\nresetButton.addEventListener(\"click\", visualization.resetVisualization);\n\n// Simulation of starting nodes and submitting rounds\nvar nodeIds = [1, 2, 3];\n\n// Initialize consensusNodes as an empty array initially\nvar consensusNodes = [];\n\n// Create consensus instances and populate the array\nnodeIds.forEach(function (id) {\n  consensusNodes.push(new Consensus(id, [])); // Temporarily use an empty array for otherConsensuses\n});\n\n// Now that consensusNodes is populated, establish connections\nconsensusNodes.forEach(function (consensus) {\n  // Filter out the current consensus instance to get the other consensuses\n  consensus.connections = consensusNodes.filter(function (c) {\n    return c !== consensus;\n  });\n});\n\n//# sourceURL=webpack:///./src/anchor.js?");

/***/ }),

/***/ "./src/time-utils.js":
/*!***************************!*\
  !*** ./src/time-utils.js ***!
  \***************************/
/***/ ((module) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// time-utils.js\nvar TimeUtils = /*#__PURE__*/function () {\n  function TimeUtils() {\n    _classCallCheck(this, TimeUtils);\n  }\n  return _createClass(TimeUtils, null, [{\n    key: \"getCurrentTime\",\n    value: function getCurrentTime() {\n      var now = new Date();\n      var hours = now.getHours().toString().padStart(2, '0');\n      var minutes = now.getMinutes().toString().padStart(2, '0');\n      var seconds = now.getSeconds().toString().padStart(2, '0');\n      var milliseconds = now.getMilliseconds().toString().padStart(3, '0');\n      return \"\".concat(hours, \":\").concat(minutes, \":\").concat(seconds, \".\").concat(milliseconds);\n    }\n  }]);\n}();\nmodule.exports = TimeUtils;\n\n//# sourceURL=webpack:///./src/time-utils.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((module) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// utils.js\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n  return _createClass(Utils, null, [{\n    key: \"updateRoundId\",\n    value: function updateRoundId(id, value) {\n      document.getElementById('roundId' + id).innerText = 'Current round ID: ' + value;\n    }\n  }, {\n    key: \"updateActiveRounds\",\n    value: function updateActiveRounds(id, value) {\n      document.getElementById('activeRounds' + id).innerText = 'Active Rounds: ' + value;\n    }\n  }, {\n    key: \"updateCommitedRounds\",\n    value: function updateCommitedRounds(id, value) {\n      document.getElementById('committedRounds' + id).innerText = 'Committed Rounds: ' + value;\n    }\n  }, {\n    key: \"updateCommittedTransactions\",\n    value: function updateCommittedTransactions(id, value) {\n      document.getElementById('committedTransactions' + id).innerText = 'Committed Transactions: ' + value;\n    }\n  }, {\n    key: \"displayCommittedRounds\",\n    value: function displayCommittedRounds(id, committedRounds) {\n      var content = '<ul>';\n      committedRounds.forEach(function (transactions, roundId) {\n        content += \"<li>Round \".concat(roundId, \": \").concat(transactions.join(', '), \"</li>\");\n      });\n      content += '</ul>';\n      var popoverButton = document.getElementById('popoverButton' + id);\n\n      // Check if the popover instance exists and is shown\n      var popoverInstance = bootstrap.Popover.getInstance(popoverButton);\n      if (popoverInstance) {\n        popoverInstance.dispose();\n        return;\n      }\n\n      // Initialize and show the popover\n      popoverInstance = new bootstrap.Popover(popoverButton, {\n        content: content,\n        html: true,\n        placement: 'bottom'\n      });\n\n      // Manually show the popover\n      popoverInstance.show();\n    }\n  }]);\n}();\nmodule.exports = Utils;\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ }),

/***/ "./src/visualization.js":
/*!******************************!*\
  !*** ./src/visualization.js ***!
  \******************************/
/***/ ((module) => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// visualization.js\n\nvar svg = d3.select(\"svg\");\n\n// Create a group to contain all nodes and clients\nvar g = svg.append(\"g\");\nvar Visualization = /*#__PURE__*/function () {\n  function Visualization(animationSpeed) {\n    _classCallCheck(this, Visualization);\n    this.animationSpeed = animationSpeed;\n    this.nodes = [];\n    this.clients = [];\n    this.currentRound = 0;\n    this.initialize();\n  }\n  return _createClass(Visualization, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n      var speedSlider = document.getElementById(\"speedSlider\");\n      var speedValue = document.getElementById(\"speedValue\");\n      speedSlider.addEventListener(\"input\", function () {\n        _this.animationSpeed = speedSlider.value;\n        speedValue.textContent = speedSlider.value;\n      });\n      this.nodes = [{\n        id: 1,\n        x: 200,\n        y: 400,\n        rounds: []\n      }, {\n        id: 2,\n        x: 500,\n        y: 200,\n        rounds: []\n      }, {\n        id: 3,\n        x: 800,\n        y: 400,\n        rounds: []\n      }];\n      this.clients = [{\n        id: 1,\n        x: 100,\n        y: 250\n      }, {\n        id: 2,\n        x: 500,\n        y: 50\n      }, {\n        id: 3,\n        x: 900,\n        y: 250\n      }];\n      this.createNodeElements();\n      this.createClientElements();\n      this.makeDraggable();\n    }\n  }, {\n    key: \"createNodeElements\",\n    value: function createNodeElements() {\n      g.append(\"g\").selectAll(\"circle\").data(this.nodes).enter().append(\"circle\").attr(\"cx\", function (d) {\n        return d.x;\n      }).attr(\"cy\", function (d) {\n        return d.y;\n      }).attr(\"r\", 60).attr(\"fill\", \"lightblue\");\n      g.append(\"g\").selectAll(\"text\").data(this.nodes).enter().append(\"text\").attr(\"x\", function (d) {\n        return d.x;\n      }).attr(\"y\", function (d) {\n        return d.y;\n      }).attr(\"dy\", 6).attr(\"text-anchor\", \"middle\").text(function (d) {\n        return 'Node ' + d.id;\n      });\n    }\n  }, {\n    key: \"createClientElements\",\n    value: function createClientElements() {\n      g.append(\"g\").selectAll(\"circle\").data(this.clients).enter().append(\"circle\").attr(\"cx\", function (d) {\n        return d.x;\n      }).attr(\"cy\", function (d) {\n        return d.y;\n      }).attr(\"r\", 20).attr(\"fill\", \"orange\");\n      g.append(\"g\").selectAll(\"text\").data(this.clients).enter().append(\"text\").attr(\"x\", function (d) {\n        return d.x;\n      }).attr(\"y\", function (d) {\n        return d.y;\n      }).attr(\"dy\", 6).attr(\"text-anchor\", \"middle\").text(function (d) {\n        return 'C' + d.id;\n      });\n    }\n  }, {\n    key: \"makeDraggable\",\n    value: function makeDraggable() {\n      var _this2 = this;\n      var drag = d3.drag().on(\"start\", function (event) {\n        // Store the initial position\n        var transform = g.attr(\"transform\");\n        if (transform) {\n          var translate = transform.match(/translate\\(([^)]+)\\)/)[1].split(\",\");\n          _this2.initialX = parseFloat(translate[0]);\n          _this2.initialY = parseFloat(translate[1]);\n        } else {\n          _this2.initialX = 0;\n          _this2.initialY = 0;\n        }\n        _this2.startX = event.x;\n        _this2.startY = event.y;\n      }).on(\"drag\", function (event) {\n        // Calculate the new position\n        var dx = event.x - _this2.startX;\n        var dy = event.y - _this2.startY;\n        g.attr(\"transform\", \"translate(\".concat(_this2.initialX + dx, \",\").concat(_this2.initialY + dy, \")\"));\n      });\n      g.call(drag);\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(source, target, message, round) {\n      var pickRound = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var curveDirection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'none';\n      var color = getColor(message);\n      if (source.rounds && source.rounds.find(function (r) {\n        return r.id === round;\n      }) && pickRound && !message.startsWith(\"transaction_\")) {\n        source = source.rounds.find(function (r) {\n          return r.id === round;\n        });\n      }\n      if (target.rounds && target.rounds.find(function (r) {\n        return r.id === round;\n      }) && pickRound && !message.startsWith(\"transaction_\")) {\n        target = target.rounds.find(function (r) {\n          return r.id === round;\n        });\n      }\n      var midX = (source.x + target.x) / 2;\n      var midY = (source.y + target.y) / 2;\n      var curveHeight = curveDirection === \"none\" ? 0 : 30;\n      var controlPointY = curveDirection === \"up\" ? midY - curveHeight : midY + curveHeight;\n      var textOffset = curveDirection === \"up\" ? -10 : 10;\n      var pathD = curveDirection === \"none\" ? \"M \".concat(source.x, \" \").concat(source.y, \" L \").concat(target.x, \" \").concat(target.y) : \"M \".concat(source.x, \" \").concat(source.y, \" C \").concat(midX, \" \").concat(controlPointY, \", \").concat(midX, \" \").concat(controlPointY, \", \").concat(target.x, \" \").concat(target.y);\n      var path = g.append(\"path\").attr(\"d\", pathD).attr(\"stroke\", color).attr(\"stroke-width\", 2).attr(\"fill\", \"none\");\n      var totalLength = path.node().getTotalLength();\n      path.attr(\"stroke-dasharray\", totalLength + \" \" + totalLength).attr(\"stroke-dashoffset\", totalLength).transition().duration(this.animationSpeed).attr(\"stroke-dashoffset\", 0).on(\"end\", function () {\n        return path.remove();\n      });\n      g.append(\"text\").attr(\"x\", midX).attr(\"y\", curveDirection !== \"none\" ? midY + textOffset : midY).attr(\"dy\", -5).attr(\"text-anchor\", \"middle\").text(message).transition().duration(this.animationSpeed).remove();\n    }\n  }, {\n    key: \"createRound\",\n    value: function createRound(node, round) {\n      var roundY = node.y + 150 + node.rounds.length * 30;\n      node.rounds.push({\n        id: round,\n        x: node.x,\n        y: roundY,\n        accepts: 0\n      });\n      g.append(\"circle\").attr(\"cx\", node.x).attr(\"cy\", roundY).attr(\"r\", 20).attr(\"fill\", \"lightgreen\");\n      g.append(\"text\").attr(\"x\", node.x).attr(\"y\", roundY).attr(\"dy\", 3).attr(\"text-anchor\", \"middle\").text(\"R\" + round);\n    }\n  }, {\n    key: \"resetVisualization\",\n    value: function resetVisualization() {\n      this.removeAllRounds();\n      this.nodes.forEach(function (node) {\n        node.rounds = [];\n        node.pendingAccepts = 0;\n      });\n    }\n  }, {\n    key: \"removeAllRounds\",\n    value: function removeAllRounds() {\n      g.selectAll(\"circle\").filter(function (d, i, nodes) {\n        return d3.select(nodes[i]).attr(\"fill\") === \"lightgreen\";\n      }).remove();\n      g.selectAll(\"text\").filter(function (d, i, nodes) {\n        return nodes[i].textContent.startsWith(\"R\");\n      }).remove();\n    }\n  }, {\n    key: \"findRound\",\n    value: function findRound(rounds, roundId) {\n      return rounds.find(function (r) {\n        return r.id === roundId;\n      });\n    }\n  }]);\n}();\nfunction getColor(message) {\n  switch (message) {\n    case \"PROPOSE\":\n      return \"blue\";\n    case \"FORWARD\":\n      return \"purple\";\n    case \"COMMIT\":\n      return \"red\";\n    case \"ACCEPT\":\n      return \"green\";\n    default:\n      return \"black\";\n  }\n}\nmodule.exports = Visualization;\n\n//# sourceURL=webpack:///./src/visualization.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/anchor.js");
/******/ 	
/******/ })()
;